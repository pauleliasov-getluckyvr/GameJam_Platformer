# Unity Development Rules

## Project Structure
- Organize assets in appropriate folders (Scripts, Prefabs, Scenes, etc.)
- Use consistent folder naming conventions
- Keep scene files in a Scenes folder
- Maintain a clear hierarchy in the Project window
- Use prefabs for reusable game objects

## Script Organization
- One component per script
- Keep MonoBehaviour scripts focused and lightweight
- Use ScriptableObjects for configuration data
- Implement interfaces for common behaviors
- Use namespaces to organize code

## Unity-Specific SOLID Principles
- Single Responsibility: Each MonoBehaviour should handle one aspect of behavior
- Open/Closed: Use ScriptableObjects and interfaces for extensible systems
- Liskov Substitution: Ensure derived components can replace base components
- Interface Segregation: Create specific interfaces for different behaviors
- Dependency Inversion: Use dependency injection for better testability

## Performance Guidelines
- Cache component references in Start/Awake
- Use object pooling for frequently spawned objects
- Minimize GetComponent calls
- Use coroutines for time-based operations
- Implement OnDisable/OnDestroy cleanup
- Use the profiler to identify bottlenecks

## Unity Best Practices
- Use [SerializeField] instead of public fields
- Implement OnValidate for editor-time validation
- Use [RequireComponent] when components are needed
- Implement IPointer interfaces for UI interactions
- Use events for loose coupling between components
- Keep Update methods lightweight

## Scene Management
- Use additive scene loading for complex games
- Implement proper scene transitions
- Use scene references instead of string names
- Keep scenes focused and modular
- Use scene-specific managers when needed

## UI Guidelines
- Use UI prefabs for consistent styling
- Implement UI scaling for different resolutions
- Use UI events instead of direct references
- Keep UI logic separate from game logic
- Use UI animation components appropriately

## Input Handling
- Use the new Input System when possible
- Implement input abstraction layers
- Handle both keyboard and gamepad inputs
- Use input events for better decoupling
- Implement proper input validation

## Resource Management
- Use Resources folder sparingly
- Implement proper asset loading/unloading
- Use Addressables for large projects
- Cache loaded resources appropriately
- Implement proper memory management

## Testing
- Use Unity Test Framework
- Create test scenes for component testing
- Implement play mode tests for runtime behavior
- Use mock objects for external dependencies
- Test UI interactions properly

## Editor Extensions
- Create custom editor windows when needed
- Implement proper editor validation
- Use [CustomEditor] for custom inspectors
- Create useful editor tools
- Follow Unity's editor UI guidelines

## Version Control
- Use Unity's meta files properly
- Keep scene files in text format
- Use .gitignore for Unity-specific files
- Handle merge conflicts in scene files carefully
- Use Unity's serialization properly

## Build Settings
- Configure proper build settings
- Set appropriate quality settings
- Handle platform-specific code properly
- Use preprocessor directives when needed
- Keep build size optimized

## Debugging
- Use Debug.Log appropriately
- Implement proper error handling
- Use Unity's debug tools effectively
- Create debug visualization tools
- Implement proper logging system 